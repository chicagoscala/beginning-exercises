h1. Chicago-Area Scala Enthusiasts (CASE) Meeting #3

p=. _April 16, 2009  @Thoughtworks_

p=. _dean@deanwampler.com_

We're doing hands-on exercises tonight.

h2. Setup

Go to GitHub to download or clone these files: "http://github.com/chicagoscala/beginning-exercises/tree/master":http://github.com/chicagoscala/beginning-exercises/tree/master.

It contains this HTML page ("web/exercises.html":web/exercises.html), a lib directory with the _ScalaTest_ jar (used below) and example solutions to the exercises.

If you want to build the exercises and run the tests, type @make@ or @build.bat@ in the directory where you put the contents.

h2. Cheat Sheet

Here are a few Scala-isms that you might find useful. Start the @scala@ interpreter and paste this text at the @scala>@ prompt.

<pre class="brush: scala;">
	val list = List(1,2,3,4)
	
	5 :: list
	
	5 :: list.reverse
	
	6 :: 5 :: list.reverse
	
	List(6, 5) ::: list.reverse
	
	list ++ List(5, 6)
	
	val (a, b) = (list, list.length)
		
	def tupledlist(l: List[_]) = (l, l.length)
	
	val (a2, b2) = tupledlist(list)
	
	list map { x => x * x }
	list foreach { x => println(x * x) }
	
	trait T1 { def m1(i: Int) }
	trait T2 { def m2(d: Double) }
	
	class C extends T1 with T2 { 
		def m1(i: Int) = println("Int: " + i) 
		def m2(d: Double) = println("Double: " + d) 
	}
	val c = new C
	c.m1(10)
	c.m2(22.2)
</pre>

Scaladocs:

* Scala API: "http://www.scala-lang.org/docu/files/api/index.html":http://www.scala-lang.org/docu/files/api/index.html
* ScalaTest: "http://www.artima.com/scalatest/doc-0.9.5/index.html":http://www.artima.com/scalatest/doc-0.9.5/index.html

h2. Functional Programming.

_"S-99: Ninety-Nine Scala Problems"_ "http://aperiodic.net/phil/scala/s-99/":http://aperiodic.net/phil/scala/s-99/

Most of the exercises (which would take days to complete) exercise functional programming.

Do the following exercises: 1-2, 4-6

Extra credit: 7, 14, 15

Take about 20-25 minutes. Try to avoid looping, mutable variables, _etc._

h2. Object-Oriented Programming

Consider a simple Bank Account class.

<pre class="brush: scala;">
package bank1
class BankAccount(var balance: Double) {
	def deposit(amount: Double) = balance += amount
	def withdraw(amount: Double) = balance -= amount
}
</pre>

(Use @package bank1@ for all files in this exercise.) What if we want to observe balance changes? Use a _Trait_ to implement the Observer Pattern.

* Define an @Account@ trait that declares the @balance@ reader, @deposit@ and @withdraw@ methods. Change the class to use the trait (@with@ keyword).

* Define another trait that defines the observer abstraction.

<pre class="brush: scala;">
trait Observer[A] {
    def receiveUpdate(x: A)
}
</pre>

* Define a _subtrait_ of @Account@ that implements the Observer pattern. Something like this:

<pre class="brush: scala;">
trait ObservedAccount extends Account {
	abstract override def deposit(amount: Double) = {
		super.deposit(amount)
		// notify observers after change. I.e., call "receiveUpdate" on each.
	}
	// Similarly for "withdraw"...
	
	// Manage list of observers (don't worry about deletion...)
}
</pre>

* Using these commands:

<pre class="brush: bash;">
scalac -classpath .:lib/scalatest-0.9.5.jar *.scala 
scala -classpath .:lib/scalatest-0.9.5.jar org.scalatest.tools.Runner -o -s bank1.ObservedBankAccountTest
</pre>

** where you copied the @lib@ directory from the zip file to your work area, ...

* ... make this _ScalaTest_ pass:

<pre class="brush: scala;">
// bank-account1-test.scala: ScalaTest to exercise code.

package bank1

import org.scalatest._
import org.scalatest.matchers._
import java.util.NoSuchElementException

class ObservedBankAccountTest extends FunSuite with ShouldMatchers {

    // I could have put the test inside "receiveUpdate", rather than
    // save the balance to "newBalance" and do the test at the end.
    // However, there's a flaw with that approach. What is it?
    test("Deposits are observed after the balance change") {
        val account = new BankAccount(100.0) with ObservedAccount
        var newBalance = 0.0
        account.addObserver(new Observer[Account] {
            def receiveUpdate(a: Account) = newBalance = a.balance
        })
        account.deposit(10.1)
        newBalance should be (110.1 plusOrMinus .01)
    }

    test("Withdraws are observed after the balance change") {
        val account = new BankAccount(100.0) with ObservedAccount
        var newBalance = 0.0
        account.addObserver(new Observer[Account] {
            def receiveUpdate(a: Account) = newBalance = a.balance
        })
        account.withdraw(10.1)
        newBalance should be (89.9 plusOrMinus .01)
    }
}
</pre>


*Note:* Solutions can be found in @bank-account1.scala@ and @bank-account1-test.scala@.

* Variation: support _before_ and _after_ observation.
** Use a boolean flag to indicate which case it is. 
** Solutions can be found in @bank-account2.scala@ and @bank-account2-test.scala@.

* Extra Credit: Use _structural typing_ for the observer abstraction. 
** Solutions can be found in @bank-account3.scala@ and @bank-account3-test.scala@.

h2. Implement the Next Google in Scala. Take about 25 minutes.
